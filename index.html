<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Smart Auto‚ÄëCrop Aramandi</title>
  <style>
    body {
      margin:0; padding:1em;
      font-family:sans-serif; text-align:center;
      background:#f0f0f0; color:#333;
    }
    h1 { margin-bottom:0.2em; }
    p { margin-bottom:1em; }
    #container {
      position:relative;
      width:100%; max-width:360px;
      margin:0 auto;
      aspect-ratio:9/16;
      background:#000;
      overflow:hidden;
    }
    canvas {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
    }
    #countdown {
      position:absolute; top:8px; right:8px;
      background:rgba(0,0,0,0.6); color:#fff;
      font-size:1.5em; padding:0.2em 0.5em;
      border-radius:4px; display:none;
    }
    .controls {
      margin-top:1em; display:flex; gap:0.5em; flex-wrap:wrap;
      justify-content:center;
    }
    .controls button {
      flex:1 1 140px; padding:0.6em; font-size:1em;
      border:1px solid #888; background:#fff;
      border-radius:4px; cursor:pointer;
    }
    @media(min-width:600px) {
      .controls {
        position:absolute; top:50%; right:-180px;
        transform:translateY(-50%); flex-direction:column;
      }
    }
  </style>
</head>
<body>

  <h1>Smart Auto‚ÄëCrop Aramandi</h1>
  <p>Get your full body in view‚Äîwhen your head clears the top slice and heels land on the orange bar, we auto‚Äëcapture.</p>

  <div id="container">
    <!-- offscreen video input -->
    <video id="video" autoplay playsinline style="display:none;"></video>
    <!-- visible canvas -->
    <canvas id="output"></canvas>
    <!-- countdown display -->
    <div id="countdown"></div>
  </div>

  <div class="controls">
    <button id="snapBtn">üì∏ Capture Photo</button>
    <button id="recBtn">üé• Record 10‚ÄØs Video</button>
    <button id="resetBtn">üîÑ Reset</button>
  </div>

  <!-- MediaPipe Pose -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  (async()=>{
    const video = document.getElementById('video');
    const canvas = document.getElementById('output');
    const ctx    = canvas.getContext('2d');
    const cdElem = document.getElementById('countdown');
    const snapBtn= document.getElementById('snapBtn');
    const recBtn = document.getElementById('recBtn');
    const resetBtn = document.getElementById('resetBtn');

    // set canvas size once we have video dimensions
    video.addEventListener('loadedmetadata',()=>{
      canvas.width  = video.videoWidth;
      canvas.height = video.videoHeight;
    });

    // start camera (user will be prompted to allow)
    const stream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:'user' }, audio:false
    });
    video.srcObject = stream;

    // state
    let lastCapture=0;
    let counting=false;

    // helper for countdown
    function startCountdown(sec, cb) {
      cdElem.style.display = 'block';
      let s=sec;
      cdElem.textContent = s;
      const iv = setInterval(()=>{
        s--;
        if(s>0) cdElem.textContent=s;
        else {
          clearInterval(iv);
          cdElem.style.display='none';
          cb();
        }
      },1000);
    }

    // pose detector
    const pose = new Pose.Pose({
      locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`
    });
    pose.setOptions({
      modelComplexity:0,
      smoothLandmarks:true,
      enableSegmentation:false,
      minDetectionConfidence:0.5,
      minTrackingConfidence:0.5
    });
    pose.onResults(drawFrame);

    // hook up camera utils to feed Pose
    const camera = new Camera.Camera(video, {
      onFrame: async()=> await pose.send({image:video}),
      width:720, height:1280
    });
    camera.start();

    // main draw loop
    function drawFrame(results){
      // if no pose, just blank
      if(!results.poseLandmarks){
        ctx.fillStyle='#000';
        ctx.fillRect(0,0,canvas.width,canvas.height);
        return;
      }

      const lm = results.poseLandmarks;
      // approximate head top: use nose y minus an offset in pixels
      const noseY = lm[0].y * canvas.height;
      const headTop = Math.max(0, noseY - (lm[0].y - lm[1].y) * canvas.height);

      // heel midpoint
      const lHeel = lm[27], rHeel = lm[28];
      const heelY = Math.max(lHeel.y, rHeel.y)*canvas.height;

      // define crop box [x: full width]
      const crop = {
        x:0, width:canvas.width,
        y:headTop, height:heelY-headTop
      };

      // draw the cropped, stretched to fill
      ctx.drawImage(
        video,
        crop.x, crop.y, crop.width, crop.height,
        0, 0, canvas.width, canvas.height
      );

      // now overlay the guides
      const H = canvas.height, W = canvas.width;
      const slice = H/8;

      // check criteria
      const headOK = (headTop <= slice*0.5);        // head *above* first slice
      const heelOK = (heelY >= H - slice*0.5);      // heel *on* last slice

      // border
      ctx.lineWidth = 8;
      ctx.strokeStyle = (headOK&&heelOK) ? 'lime' : 'red';
      ctx.strokeRect(0,0,W,H);

      // 8‚Äêslice horizontal
      ctx.lineWidth = 3;
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = (headOK&&heelOK) ? 'lime' : 'red';
      for(let i=1;i<8;i++){
        const y=i*slice;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(W,y);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // orange landing bar at bottom slice
      ctx.fillStyle='orange';
      ctx.fillRect(0,7*slice, W, slice);

      // auto‚Äëtrigger a capture once
      if(headOK&&heelOK && !counting && Date.now()-lastCapture>5000){
        counting = true;
        startCountdown(5, ()=>{ snap(); counting=false; });
      }
    }

    function snap(){
      lastCapture = Date.now();
      const img = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = img;
      a.download = 'aramandi.png';
      a.click();
    }

    // manual buttons
    snapBtn.addEventListener('click',()=>{
      if(counting)return;
      counting=true;
      startCountdown(5,()=>{
        snap(); counting=false;
      });
    });
    recBtn.addEventListener('click',()=>{
      if(counting)return;
      counting=true;
      startCountdown(5,()=>{
        // record 10‚ÄØs
        const rec = new MediaRecorder(stream, {mimeType:'video/webm'});
        const chunks=[];
        rec.ondataavailable = e=>chunks.push(e.data);
        rec.onstop = ()=>{
          const blob=new Blob(chunks,{type:'video/webm'});
          const u=URL.createObjectURL(blob);
          const a=document.createElement('a');
          a.href=u; a.download='aramandi.webm'; a.click();
          URL.revokeObjectURL(u);
        };
        rec.start();
        setTimeout(()=>rec.state!=='inactive'&&rec.stop(),10000);
        counting=false;
      });
    });
    resetBtn.addEventListener('click',()=>{
      counting=false;
      cdElem.style.display='none';
    });

  })();
  </script>

</body>
</html>
