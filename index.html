<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Autoâ€‘Framed Aramandi Capture</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f0f0f0;
      text-align: center;
      color: #333;
    }
    h1 { margin: 1rem 0 0.5rem; }
    #instructions { margin-bottom: 1rem; padding: 0 1rem; }
    #container {
      position: relative;
      margin: 0 auto;
      width: 90vw;
      max-width: 720px;            /* for desktop */
      aspect-ratio: 9 / 16;        /* always portrait */
      background: #000;
      overflow: hidden;
    }
    #video, #canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    #canvas { pointer-events: none; }
    #controls {
      margin: 1rem 0;
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    button {
      font-size: 1rem;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    #countdown {
      font-size: 1.5rem;
      font-weight: bold;
      color: #d00;
      height: 1.5em;
    }
  </style>
</head>
<body>
  <h1>Autoâ€‘Framed Aramandi Capture</h1>
  <p id="instructions">
    Get your <b>entire body</b> in view. When youâ€™re ready, click to start the 5Â s countdownâ€”remain still until your photo/video snaps.
  </p>

  <div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
  </div>

  <div id="controls">
    <button id="photo-btn">ðŸ“¸ Capture Photo</button>
    <button id="video-btn">ðŸŽ¥ Record 10Â s Video</button>
  </div>
  <div id="countdown"></div>

  <!-- MediaPipe Pose + Camera Utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  const video      = document.getElementById('video');
  const canvas     = document.getElementById('canvas');
  const ctx        = canvas.getContext('2d');
  const photoBtn   = document.getElementById('photo-btn');
  const videoBtn   = document.getElementById('video-btn');
  const countdown  = document.getElementById('countdown');
  let mediaRecorder, chunks = [];

  // 1) Initialize MediaPipe Pose
  const pose = new Pose({
    locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`
  });
  pose.setOptions({
    modelComplexity: 0,
    smoothLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  pose.onResults(onPose);

  // 2) Start camera
  const cam = new Camera(video, {
    onFrame: async () => await pose.send({image: video}),
    width: 1280, height: 720,
    facingMode: 'user'
  });
  cam.start();

  // 3) Handle each pose result â€” compute a tight 9Ã—16 crop around headâ†’heels
  let lastBox = null;
  function onPose(results) {
    if (!results.poseLandmarks) {
      return drawBlack();
    }

    const W = video.videoWidth, H = video.videoHeight;
    // landmarks in normalized coords
    const lm = results.poseLandmarks;
    // find yâ€‘range from forehead to heel midpoint:
    let topY = 1, botY = 0;
    // using landmark indices: 0:nose, 2:eye_right,5:eye_left, 27:left_heel,28:right_heel
    const candidates = [
      lm[0], lm[2], lm[5],
      {x: (lm[27].x+lm[28].x)/2, y: (lm[27].y+lm[28].y)/2}
    ];
    for (let p of candidates) {
      topY = Math.min(topY, p.y);
      botY = Math.max(botY, p.y);
    }
    // add 10% margin
    const heightN = botY - topY;
    topY -= heightN*0.1;
    botY += heightN*0.1;

    // clip
    topY = Math.max(0, topY);
    botY = Math.min(1, botY);

    // compute crop height in px, then width so that aspect 9Ã—16 preserved
    const cropH = (botY - topY)*H;
    const cropW = cropH * (9/16);
    // center crop horizontally around hip midpoint:
    const hipMidX = (lm[23].x + lm[24].x)/2; // left_hip(23), right_hip(24)
    const centerX = hipMidX * W;
    let x0 = centerX - cropW/2;
    x0 = Math.max(0, Math.min(W-cropW, x0));    // clamp
    const y0 = topY * H;

    lastBox = {x0,y0,cropW,cropH};
    drawFrame();
  }

  function drawBlack() {
    const cw = canvas.width, ch = canvas.height;
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cw,ch);
  }

  // 4) paint video â†’ canvas using lastBox as crop
  function drawFrame() {
    if (!lastBox) return;
    // ensure canvas is same display size as video
    canvas.width  = video.clientWidth;
    canvas.height = video.clientHeight;
    const scaleX = video.videoWidth  / video.clientWidth;
    const scaleY = video.videoHeight / video.clientHeight;

    const sx = lastBox.x0;
    const sy = lastBox.y0;
    const sw = lastBox.cropW;
    const sh = lastBox.cropH;
    // draw
    ctx.drawImage(
      video,
      sx, sy, sw, sh,
      0, 0, canvas.width, canvas.height
    );
  }

  // 5) 5s countdown helper
  function doCountdown(sec, cb) {
    countdown.textContent = sec;
    let c = sec;
    const t = setInterval(()=>{
      c--;
      if (c>0) countdown.textContent=c;
      else {
        clearInterval(t);
        countdown.textContent='';
        cb();
      }
    },1000);
  }

  // 6) Capture Photo (full native crop)
  photoBtn.onclick = ()=>{
    doCountdown(5, ()=>{
      if (!lastBox) return alert('No frame');
      const {x0,y0,cropW,cropH} = lastBox;
      const cap = document.createElement('canvas');
      cap.width  = cropW;
      cap.height = cropH;
      const c2 = cap.getContext('2d');
      c2.drawImage(video, x0,y0,cropW,cropH, 0,0,cropW,cropH);
      cap.toBlob(b=>{
        const url = URL.createObjectURL(b);
        const a   = document.createElement('a');
        a.href    = url;
        a.download= 'aramandi.png';
        document.body.appendChild(a);
        a.click(); a.remove();
        URL.revokeObjectURL(url);
      },'image/png');
    });
  };

  // 7) Record Video (10s max) â€” we reâ€‘record the raw camera stream, then crop later if you like
  videoBtn.onclick = ()=>{
    doCountdown(5, ()=>{
      recordedChunks = [];
      const stream = video.srcObject;
      try {
        mediaRecorder = new MediaRecorder(stream, {mimeType:'video/webm'});
      } catch(e){
        return alert('Recorder error: '+e);
      }
      mediaRecorder.ondataavailable = e=>{
        if (e.data.size>0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = ()=>{
        const blob = new Blob(recordedChunks,{type:'video/webm'});
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href     = url;
        a.download = 'aramandi.webm';
        document.body.appendChild(a);
        a.click(); a.remove();
        URL.revokeObjectURL(url);
      };
      mediaRecorder.start();
      setTimeout(()=>mediaRecorder.state!=='inactive'&&mediaRecorder.stop(),10000);
    });
  };

  // redraw on each animation tick
  function loop() {
    drawFrame();
    requestAnimationFrame(loop);
  }
  loop();
  </script>
</body>
</html>
